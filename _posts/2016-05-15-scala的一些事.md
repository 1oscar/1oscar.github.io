---
layout: post
title: "scala的一些事" 
comments: true
share: true
tags: scala
---

**只mark值得记录的**
**关于scala更多的内容，详见《那条路》笔记本上的总结内容。**<br>
**关于scala安装相关内容，详见evernote notes**

1.   **类名**

      对于所有的类名的第一个字母要大写。如果需要使用几个单词来构成一个类的名称，每个单词的第一个字母要大写。方法名称 - 所有的方法名称的第一个字母用小写。如果若干单词被用于构成方法的名称，则每个单词的第一个字母应大写。

2.

    def main(args: Array[String]) - Scala程序从main()方法开始处理，这是每一个Scala程序的强制程序入口部分。

3. **scala多变量声明**

```
val xmax, ymax =  100  // xmax, ymax都声明为100

或声明元组：
val (myVar1, myVar2)  =  Pair(40,  "Foo")
```

4.**for循环过滤**

```
for( var x <- Range if condition1; if condition2...
){
   statement(s);
}
Range 可以是一个数字区间表示 i to j ，或者 i until j。左箭头 <- 用于为变量 x 赋值。分号便表示&&
```


5.  **for 循环的返回值作为一个变量存储**

```
  var x=0;
var retVal = for{ var x <- List
     if condition1; if condition2...
}yield x
将for循环过滤的圆括号变成大括号。 大括号中用于保存变量和条件, yield 会把当前的元素记下来，保存在集合中，循环结束后将返回该集合retVal。
```

```
object Test {
   def main(args: Array[String]) {
      var a = 0;
      val numList = List(1,2,3,4,5,6,7,8,9,10);

      // for 循环
      var retVal = for{ a <- numList 
                        if a != 3; if a < 8
                      }yield a

      // 输出返回值
      for( a <- retVal){
         println( "Value of a: " + a );
      }
   }
}
```

6.**中断循环，功能类似break；scala里无break；**

```
// 导入以下包
import scala.util.control._

// 创建 Breaks 对象
val loop = new Breaks;

// 在 breakable 中循环
loop.breakable{
    // 循环
    for(...){
       ....
       // 循环中断
       loop.break;
   }
}
```

7.**函数声明**

```
def functionName ([参数列表]) : [return type] = {
   function body
   return [expr]
}
object add{
   def addInt( a:Int, b:Int ) : Int = {
      var sum:Int = 0
      sum = a + b

      return sum
   }
}
def functionName ([参数列表]) : [return type]
如果你不写等于号和方法主体，那么方法会被隐式声明为"抽象(abstract)"
```

```
如果函数没有返回值，可以返回为 Unit，这个类似于 Java 的 void,
object Hello{
   def printMe( ) : Unit = {
      println("Hello, Scala!")
   }
}
```

8.

	* 传值调用（call-by-value）：先计算参数表达式的值，再应用到函数内部；
	* 传名调用（call-by-name）：将未计算的参数表达式直接应用到函数内部

变量名和变量类型使用 => 符号来设置传名调用

```
def delayed( t: => Long ) = {
      println("在 delayed 方法内")
      println("参数： " + t)
      t
   }
```

9. **Scala 通过在参数的类型之后放一个星号来设置可变参数(可重复的参数)。**

```
object Test {
   def main(args: Array[String]) {
        printStrings("Runoob", "Scala", "Python");
   }
   def printStrings( args:String* ) = {
      var i : Int = 0;
      for( arg <- args ){
         println("Arg value[" + i + "] = " + arg );
         i = i + 1;
      }
   }
}
```

10.**匿名函数**

```
var inc =  (x:Int)  => x+1
箭头左边是参数列表，右边是函数体，参数的类型是可省略的，Scala 的类型推测系统会推测出参数的类型
```

11.**偏应用函数**

绑定第一个 date 参数，第二个参数使用下划线(_)替换缺失的参数列表，并把这个新的函数值的索引赋给变量

```
import java.util.Date

object Test {
   def main(args: Array[String]) {
      val date = new Date
      val logWithDateBound = log(date, _ : String)

      logWithDateBound("message1" )
      Thread.sleep(1000)
      logWithDateBound("message2" )
      Thread.sleep(1000)
      logWithDateBound("message3" )
   }

   def log(date: Date, message: String)  = {
     println(date + "----" + message)
   }
}
```

12。**函数柯里化**

```
def add(x:Int,y:Int)=x+y
柯里化后：
def add(x:Int)(y:Int)  = x + y
```

13.**闭包**

```
闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量
object Test { 
   def main(args: Array[String]) { 
      println( "muliplier(1) value = " +  multiplier(1) ) 
      println( "muliplier(2) value = " +  multiplier(2) ) 
   } 
   var factor = 3 
   val multiplier = (i:Int) => i * factor 
}
```

14.**字符串相关：**

```
可变对象定义：
val buf = new StringBuilder;
buf += 'a';
字符串长度：s.length()
连接：s1.concat(s2)
这里相关函数同java。如trim(),toString(),subString(),split(),replace()等等

```

15.**数组：**

```
scala数组申明
var z = new Array[String](3)
或 
var z = Array("Runoob", "Baidu", "Google")
数组索引：
z(0) = "Runoob";
二维数组定义：
var myMatrix = Array.ofDim[Int](3,3)
数组连接成一个数组。
var myList1 = Array(1.9, 2.9, 3.4, 3.5)
      var myList2 = Array(8.9, 7.9, 0.4, 1.5)

      var myList3 =  Array.concat( myList1, myList2) ：保持两个数组原有顺序。
生成数组：Array.range(10,20,2)： 生成10开始，20结束，步长为2的数组，Array.range(10,20)，默认步长为1。
```

16.**List**

```
List：有序，有重复   Set：无序，无重复    map：同java
元组：不同类型值的集合。迭代器
定义map：
val x = Map("one" -> 1, "two" -> 2, "three" -> 3)
List：空列表：List() 或者  Nil 也可以表示为一个空列表。
二维列表：
val dim: List[List[Int]] =
   List(
      List(1, 0, 0),
      List(0, 1, 0),
      List(0, 0, 1)
   )
eleList.head ：返回列表第一个元素，eleList.tail: 返回除第一个元素外的列表。eleList.isEmpty： 如果eleList为空，，返回 True。
eleList.init: 返回所有元素，除了最后一个。
字符串列表：
val site = "Runoob" :: ("Google" :: ("Baidu" :: Nil))
或者  val site = List("Runoob", "Google", "Baidu")
连接链表：   使用 ::: 运算符或 List.:::() 方法或 List.concat() 方法来连接两个或多个列表组合成一个列表。
val site = List.fill(3)("Runoob") //重复Runoob三次，返回一个List类型

List.tabulate() 方法是通过给定的函数来创建列表。
val squares = List.tabulate(6)(n => n * n)  结果： squares: List[Int] = List(0, 1, 4, 9, 16, 25)
eleList.reverse: 列表元素反转
list->String: 
val b = new StringBuilder
val a = List(1,2,3)
val c = a.addString(b,",") //指定分隔符,分割。
或者 a.mkString(",")
将List(1,2,3) --》 {1,2,3}
def addString(b: StringBuilder, start: String, sep: String, end: String)
val a = List(1,2,3,4)
valb =newStringBuilder()
valc = a.addString(b,"{",",","}" // c: {1,2,3,4}
a.apply(0) 同a(0) 取出指定索引处的元素。
a.contains(ele)： 判断是否包含ele，返回boolean类型。
a.distinct: 返回a的去重后的列表
val a = Array(3, 2, 3,4)
val b =Array(3,4)
println(a.endsWith(b))//true  判断是否以b结尾
a.equals(b)：判断是否相等。
a.length:返回长度。
a.max：最小元素。
a.min:最大元素。
a.sorted: 列表排序，默认升序。
a.sum: 求和
a.take(2):提取列表的前2个元素。
a.takeRight(2):提取列表的后两个元素。
a.toArray： 列表转为数组
a.toMap: 转为map，a为二维数组
a.toSeq： 转为Seq,包含重复
a.toSet: 转为Set，去重。
a.toString: 转为String。
a.drop(n):丢弃前n个元素，返回余下的列表
a.dropRight(n):丢弃后n个元素。返回余下的列表
判断当前数组是否包含符合条件的元素
val a = Array(3, 2, 3,4)
println(a.exists( {x:Int => x==3} ))//true
println(a.exists( {x:Int => x==30} ))//false
遍历序列中的元素，进行 f 操作
def foreach(f: (A) ⇒ Unit): Unit 
val a = Array(1, 2, 3,4)
a.foreach(x => println(x*10))
备注：列表的以上操作Array也可以这样操作。
下表列出了 Scala List 常用的方法：
+
方法描述def +(elem: A): List[A]为列表预添加元素def ::(x: A): List[A]在列表开头添加元素def :::(prefix: List[A]): List[A]在列表开头添加指定列表的元素def ::(x: A): List[A]在列表开头添加元素 xdef addString(b: StringBuilder): StringBuilder将列表的所有元素添加到 StringBuilderdef addString(b: StringBuilder, sep: String): StringBuilder将列表的所有元素添加到 StringBuilder，并指定分隔符def apply(n: Int): A通过列表索引获取元素def contains(elem: Any): Boolean检测列表中是否包含指定的元素def copyToArray(xs: Array[A], start: Int, len: Int): Unit将列表的元素复制到数组中。def distinct: List[A]去除列表的重复元素，并返回新列表def drop(n: Int): List[A]丢弃前n个元素，并返回新列表def dropRight(n: Int): List[A]丢弃最后n个元素，并返回新列表def dropWhile(p: (A) => Boolean): List[A]从左向右丢弃元素，直到条件p不成立def endsWith[B](that: Seq[B]): Boolean检测列表是否以指定序列结尾def equals(that: Any): Boolean判断是否相等def exists(p: (A) => Boolean): Boolean判断列表中指定条件的元素是否存在。判断l是否存在某个元素:scala&gt; l.exists(s =&gt; s == "Hah") res7: Boolean = truedef filter(p: (A) => Boolean): List[A]输出符号指定条件的所有元素。过滤出长度为3的元素:scala&gt; l.filter(s =&gt; s.length == 3) res8: List[String] = List(Hah, WOW)def forall(p: (A) => Boolean): Boolean检测所有元素。例如：判断所有元素是否以"H"开头：scala&gt; l.forall(s =&gt; s.startsWith("H")) res10: Boolean = falsedef foreach(f: (A) => Unit): Unit将函数应用到列表的所有元素def head: A获取列表的第一个元素def indexOf(elem: A, from: Int): Int从指定位置 from 开始查找元素第一次出现的位置def init: List[A]返回所有元素，除了最后一个def intersect(that: Seq[A]): List[A]计算多个集合的交集def isEmpty: Boolean检测列表是否为空def iterator: Iterator[A]创建一个新的迭代器来迭代元素def last: A返回最后一个元素def lastIndexOf(elem: A, end: Int): Int在指定的位置 end 开始查找元素最后出现的位置def length: Int返回列表长度def map[B](f: (A) => B): List[B]通过给定的方法将所有元素重新计算def max: A查找最大元素def min: A查找最小元素def mkString: String列表所有元素作为字符串显示def mkString(sep: String): String使用分隔符将列表所有元素作为字符串显示def reverse: List[A]列表反转def sorted[B >: A]: List[A]列表排序def startsWith[B](that: Seq[B], offset: Int): Boolean检测列表在指定位置是否包含指定序列def sum: A计算集合元素之和def tail: List[A]返回所有元素，除了第一个def take(n: Int): List[A]提取列表的前n个元素def takeRight(n: Int): List[A]提取列表的后n个元素def toArray: Array[A]列表转换为数组def toBuffer[B >: A]: Buffer[B]返回缓冲区，包含了列表的所有元素def toMap[T, U]: Map[T, U]List 转换为 Mapdef toSeq: Seq[A]List 转换为 Seqdef toSet[B >: A]: Set[B]List 转换为 Setdef toString(): String
列表转换为字符串
```

17.**set同List，补充set独有的**

```
交集：   使用 Set.& 方法或 Set.intersect 方法来查看两个集合的交集元素
      val num1 = Set(5,6,9,20,30,45)
      val num2 = Set(50,60,9,20,35,55)

      // 交集
      println( "num1.&(num2) : " + num1.&(num2) )
      println( "num1.intersect(num2) : " + num1.intersect(num2) )
可变集合：
import scala.collection.mutable.Set // 可以在任何地方引入 可变集合

val mutableSet = Set(1,2,3)
println(mutableSet.getClass.getName) // scala.collection.mutable.HashSet

mutableSet.add(4)
mutableSet.remove(1)
mutableSet += 5
mutableSet -= 2

println(mutableSet) // Set(5, 3, 4)

val another = mutableSet.toSet
println(another.getClass.getName) // scala.collection.immutable.Set
可变Set和不可变Set都有添加或删除元素的操作，但是有一个非常大的差别。对不可变Set进行操作，会产生一个新的set，原来的set并没有改变，这与List一样。 而对可变Set进行操作，改变的是该Set本身，与ListBuffer类似。
集合连接： 使用 ++ 运算符或 Set.++() 方法来连接两个集合
下表列出了 Scala Set 常用的方法：
方法描述def +(elem: A): Set[A]为集合添加新元素，x并创建一个新的集合，除非元素已存在def -(elem: A): Set[A]移除集合中的元素，并创建一个新的集合def contains(elem: A): Boolean如果元素在集合中存在，返回 true，否则返回 false。def &(that: Set[A]): Set[A]返回两个集合的交集def &~(that: Set[A]): Set[A]返回两个集合的差集def +(elem1: A, elem2: A, elems: A*): Set[A]通过添加传入指定集合的元素创建一个新的不可变集合def ++(elems: A): Set[A]合并两个集合def -(elem1: A, elem2: A, elems: A*): Set[A]通过移除传入指定集合的元素创建一个新的不可变集合def addString(b: StringBuilder): StringBuilder将不可变集合的所有元素添加到字符串缓冲区def addString(b: StringBuilder, sep: String): StringBuilder将不可变集合的所有元素添加到字符串缓冲区，并使用指定的分隔符def apply(elem: A)检测集合中是否包含指定元素def count(p: (A) => Boolean): Int计算满足指定条件的集合元素个数def copyToArray(xs: Array[A], start: Int, len: Int): Unit复制不可变集合元素到数组def diff(that: Set[A]): Set[A]比较两个集合的差集def drop(n: Int): Set[A]]返回丢弃前n个元素新集合def dropRight(n: Int): Set[A]返回丢弃最后n个元素新集合def dropWhile(p: (A) => Boolean): Set[A]从左向右丢弃元素，直到条件p不成立def equals(that: Any): Booleanequals 方法可用于任意序列。用于比较系列是否相等。def exists(p: (A) => Boolean): Boolean判断不可变集合中指定条件的元素是否存在。def filter(p: (A) => Boolean): Set[A]输出符合指定条件的所有不可变集合元素。def find(p: (A) => Boolean): Option[A]查找不可变集合中满足指定条件的第一个元素def forall(p: (A) => Boolean): Boolean查找不可变集合中满足指定条件的所有元素def foreach(f: (A) => Unit): Unit将函数应用到不可变集合的所有元素def head: A获取不可变集合的第一个元素def init: Set[A]返回所有元素，除了最后一个def intersect(that: Set[A]): Set[A]计算两个集合的交集def isEmpty: Boolean判断集合是否为空def iterator: Iterator[A]创建一个新的迭代器来迭代元素def last: A返回最后一个元素def map[B](f: (A) => B): immutable.Set[B]通过给定的方法将所有元素重新计算def max: A查找最大元素def min: A查找最小元素def mkString: String集合所有元素作为字符串显示def mkString(sep: String): String使用分隔符将集合所有元素作为字符串显示def product: A返回不可变集合中数字元素的积。def size: Int返回不可变集合元素的数量def splitAt(n: Int): (Set[A], Set[A])把不可变集合拆分为两个容器，第一个由前 n 个元素组成，第二个由剩下的元素组成def subsetOf(that: Set[A]): Boolean如果集合中含有子集返回 true，否则返回falsedef sum: A返回不可变集合中所有数字元素之和def tail: Set[A]返回一个不可变集合中除了第一元素之外的其他元素def take(n: Int): Set[A]返回前 n 个元素def takeRight(n: Int):Set[A]返回后 n 个元素def toArray: Array[A]将集合转换为数字def toBuffer[B >: A]: Buffer[B]返回缓冲区，包含了不可变集合的所有元素def toList: List[A]返回 List，包含了不可变集合的所有元素def toMap[T, U]: Map[T, U]返回 Map，包含了不可变集合的所有元素def toSeq: Seq[A]返回 Seq，包含了不可变集合的所有元素def toString(): String返回一个字符串，以对象来表示
```

18.**map 也叫哈希表。**

```

      val colors = Map("red" -> "#FF0000",
                       "azure" -> "#F0FFFF",
                       "peru" -> "#CD853F")

      val nums: Map[Int, Int] = Map()

      println( "colors 中的键为 : " + colors.keys )
      println( "colors 中的值为 : " + colors.values )
      println( "检测 colors 是否为空 : " + colors.isEmpty )
      println( "检测 nums 是否为空 : " + nums.isEmpty )
 
使用 ++ 运算符或 Map.++() 方法来连接两个 Map，Map 合并时会移除重复的 key
var colors = colors1 ++ colors2
eleMap.keys.foreach{ i => 
                           print( "Key = " + i )
                           println(" Value = " + sites(i) )}

下表列出了 Scala Map 常用的方法：
方法描述def ++(xs: Map[(A, B)]): Map[A, B]返回一个新的 Map，新的 Map xs 组成def -(elem1: A, elem2: A, elems: A*): Map[A, B]返回一个新的 Map, 移除 key 为 elem1, elem2 或其他 elems。def --(xs: GTO[A]): Map[A, B]返回一个新的 Map, 移除 xs 对象中对应的 keydef get(key: A): Option[B]返回指定 key 的值def iterator: Iterator[(A, B)]创建新的迭代器，并输出 key/value 对def addString(b: StringBuilder): StringBuilder将 Map 中的所有元素附加到StringBuilder，可加入分隔符def addString(b: StringBuilder, sep: String): StringBuilder将 Map 中的所有元素附加到StringBuilder，可加入分隔符def apply(key: A): B返回指定键的值，如果不存在返回 Map 的默认方法def clear(): Unit清空 Mapdef clone(): Map[A, B]从一个 Map 复制到另一个 Mapdef contains(key: A): Boolean如果 Map 中存在指定 key，返回 true，否则返回 false。def copyToArray(xs: Array[(A, B)]): Unit复制集合到数组def count(p: ((A, B)) => Boolean): Int计算满足指定条件的集合元素数量def default(key: A): B定义 Map 的默认值，在 key 不存在时返回。def drop(n: Int): Map[A, B]返回丢弃前n个元素新集合def dropRight(n: Int): Map[A, B]返回丢弃最后n个元素新集合def dropWhile(p: ((A, B)) => Boolean): Map[A, B]从左向右丢弃元素，直到条件p不成立def empty: Map[A, B]返回相同类型的空 Mapdef equals(that: Any): Boolean如果两个 Map 相等(key/value 均相等)，返回true，否则返回falsedef exists(p: ((A, B)) => Boolean): Boolean判断集合中指定条件的元素是否存在def filter(p: ((A, B))=> Boolean): Map[A, B]返回满足指定条件的所有集合def filterKeys(p: (A) => Boolean): Map[A, B]返回符合指定条件的的不可变 Mapdef find(p: ((A, B)) => Boolean): Option[(A, B)]查找集合中满足指定条件的第一个元素def foreach(f: ((A, B)) => Unit): Unit将函数应用到集合的所有元素def init: Map[A, B]返回所有元素，除了最后一个def isEmpty: Boolean检测 Map 是否为空def keys: Iterable[A]返回所有的key/p>def last: (A, B)返回最后一个元素def max: (A, B)查找最大元素def min: (A, B)查找最小元素def mkString: String集合所有元素作为字符串显示def product: (A, B)返回集合中数字元素的积。def remove(key: A): Option[B]移除指定 keydef retain(p: (A, B) => Boolean): Map.this.type如果符合满足条件的返回 truedef size: Int返回 Map 元素的个数def sum: (A, B)返回集合中所有数字元素之和def tail: Map[A, B]返回一个集合中除了第一元素之外的其他元素def take(n: Int): Map[A, B]返回前 n 个元素def takeRight(n: Int): Map[A, B]返回后 n 个元素def takeWhile(p: ((A, B)) => Boolean): Map[A, B]返回满足指定条件的元素def toArray: Array[(A, B)]集合转数组def toBuffer[B >: A]: Buffer[B]返回缓冲区，包含了 Map 的所有元素def toList: List[A]返回 List，包含了 Map 的所有元素def toSeq: Seq[A]返回 Seq，包含了 Map 的所有元素def toSet: Set[A]返回 Set，包含了 Map 的所有元素def toString(): String
返回字符串对象
```

19.**元组**

```
定义： val t =  (1,  3.14,  "Fred") 或 val t = Tuple2("a","b")
使用 t._1 访问第一个元素， t._2 访问第二个元素
Tuple.productIterator() 方法来迭代输出元组的所有元素
val t = (4,3,2,1)
t.productIterator.foreach{ i =>println("Value = " + i )}
Tuple.toString() 方法将元组的所有元素组合成一个字符串
使用 Tuple.swap 方法来交换元组的元素
t.swap
```

20.**迭代器**

```
val it = Iterator("Baidu", "Google", "Runoob", "Taobao")
it.hashNext:  检测集合中是否还有元素。
it.next:  返回迭代器的下一个元素
 it.min 和 it.max 方法从迭代器中查找最大与最小元素
it.size | 或 it.length | 方法来查看迭代器中的元素个数
```

21:** 类：**

```
Scala中的类不声明为public，一个Scala源文件中可以有多个类。 方法没有返回值
重写方法： override       继承类： extends 
Scala 中，是没有 static 这个东西的， 使用关键字 object 实现单例模式。
Scala 中使用单例模式时，除了定义的类之外，还要定义一个同名的 object 对象，它和类的区别是，object对象不能带参数。如果object对象与类同名，则此对象成为伴生对象，此类成为伴生类。
```

22.

```
Scala Trait(特征) 相当于 Java 的接口，与接口不同的是，它还可以定义属性和方法的实现。
Scala的类只能够继承单一父类，但是如果是 Trait(特征) 的话就可以继承多个，从结果来看就是实现了多重继承。
```

23.**模式匹配对应java中switch。   选择器 match {备选项}。**

```
object Test {
   def main(args: Array[String]) {
      println(matchTest("two"))
      println(matchTest("test"))
      println(matchTest(1))
      println(matchTest(6))

   }
   def matchTest(x: Any): Any = x match {
      case 1 => "one"
      case "two" => 2
      case y: Int => "scala.Int"
      case _ => "many"
   }
}
第四个 case 表示默认的全匹配备选项，即没有找到其他匹配时的匹配项，类似 switch 中的 default。
+
```

24.** scala正则表达式**

```
import scala.util.matching.Regex

object Test {
   def main(args: Array[String]) {
      val pattern = "Scala".r
      val str = "Scala is Scalable and cool"

      println(pattern findFirstIn str)
   }
}

构造正则对象： 
1.  String 类的 r() 方法构造了一个Regex对象。（val pattern = "Scala".r）
2.val pattern = new Regex("(S|s)cala")  // 首字母可以是大写 S 或小写 s

findFirstIn 方法找到首个匹配项。需要查看所有的匹配项可以使用 findAllIn 方法。使用 mkString( ) 方法来连接正则表达式匹配结果的字符串
println((pattern findAllIn str).mkString(","))   // 使用逗号 , 连接返回结果
使用 replaceFirstIn( ) 方法来替换第一个匹配项，使用replaceAllIn( ) 方法替换所有匹配项
println(pattern replaceFirstIn(str, "Java"))
```

25.**异常：**

```
import java.io.FileReader
import java.io.FileNotFoundException
import java.io.IOException

object Test {
   def main(args: Array[String]) {
      try {
         val f = new FileReader("input.txt")
      } catch {
         case ex: FileNotFoundException => {
            println("Missing file exception")
         }
         case ex: IOException => {
            println("IO Exception")
         }
      } finally {
         println("Exiting finally...")
      }
   }
}
+
```

26.**文件io**

```
写入文件：
      val writer = new PrintWriter(new File("test.txt" ))

      writer.write("菜鸟教程")
      writer.close()


从屏幕读取用户输入：
val line = Console.readLine
println("谢谢，你输入的是: " + line)


从文件读取内容： 使用 Scala 的 Source 类及伴生对象来读取文件

import scala.io.Source

object Test {
   def main(args: Array[String]) {
      println("文件内容为:" )

      val resp = Source.fromFile("D:\\scala project\\exercise\\test.txt" ).getLines()
      for(line <- resp){
        println(line.length+" "+line)
      }
   }
}
```

**容易被忽视的：**

```
1.退出scala交互式窗口：      ：q
2.编译后(scalac ***.scala)：**$class.class一般是特征trait修饰，**$.class一般是单例对象object定义的，只有**.class是类class定义的。
3. 箭头符号 => 隔开了表达式。=  隔开方法实现。_ 表示所有或者每一个元素。<- 一般用在for循环里，循环每一个元素。
```
